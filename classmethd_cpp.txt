typedef struct {
    PyObject_HEAD
    PyFunctionObject *function_wrapper;
    PyObject *owner;
    PyFunctionObject * __wrapped__; // old function
} Py_ClassMethodObject;

// ClassMethod __new__
static PyObject * Py_ClassMethod_New(PyTypeObject *type, PyObject *args, PyObject *kwargs){
    Py_ClassMethodObject *obj = (Py_ClassMethodObject *)type->tp_alloc(type, 0);
    if (!obj){
        std::printf("Testing for Runtime.");
        return NULL;
    }
    return (PyObject *) obj;
}

static int Py_ClassMethod_init(Py_ClassMethodObject *self, PyObject *args, PyObject *kwargs){
    PyObject *funcobj;
    std::printf("Started __init__\n");
    std::printf("What\n");
    if (!PyArg_ParseTuple(args, "O", funcobj)){
        std::printf("Error Occured\n");
        return NULL;
    }
    else if (funcobj == NULL){
        PyObject *pystring = PyUnicode_FromString("args was null");
        PyErr_SetObject(PyExc_Exception, pystring);
        return -1;
    }
    Py_XINCREF(funcobj);
    self->__wrapped__ = (PyFunctionObject *)funcobj;
    std::printf("Hello\n");
    char func_string[] = "lambda self, *args, **kwargs: self.__wrapped__(self.owner, *args, **kwargs)";
    self->function_wrapper = (PyFunctionObject *) PyRun_String(func_string,
                Py_single_input, PyEval_GetGlobals(), PyEval_GetLocals());
    self->function_wrapper->func_name = self->__wrapped__->func_name;
    self->function_wrapper->func_module = self->__wrapped__->func_module;
    self->function_wrapper->func_doc = self->__wrapped__->func_doc;
    std::printf("Hello\n");
}

static PyObject * Py_ClassMethod_Function(Py_ClassMethodObject *self, PyObject *owner){
    self->owner = owner;
    return (PyObject *)self->function_wrapper;
}

/*static PyObject * Py_ClassMethod_wrapper(Py_ClassMethodObject *self, PyObject *args, PyObject *kwargs){
    return self->function_wrapper(self->owner, args, kwargs);
}*/

static PyObject * Py_ClassMethod_get(Py_ClassMethodObject *self, PyObject *instance, PyObject *owner){
    return Py_ClassMethod_Function(self, owner);
}

static PyMemberDef Py_ClassMethodType_members[] = {
    {"__wrapped__", T_OBJECT_EX, offsetof(Py_ClassMethodObject, __wrapped__)},
    {"owner", T_OBJECT_EX, offsetof(Py_ClassMethodObject, owner)},
    {NULL}
};

/* classmethod definition. */
static PyTypeObject Py_ClassMethodType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "classmethod",
    .tp_basicsize = sizeof(Py_ClassMethodObject),
    .tp_itemsize = 0,
    .tp_getattr = (getattrfunc) PyObject_GenericGetAttr,
    .tp_setattr = (setattrfunc) PyObject_GenericSetAttr,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_doc = "A Class Method in C++.",
    .tp_members = Py_ClassMethodType_members,
    .tp_descr_get = (descrgetfunc) Py_ClassMethod_get,
    .tp_init = (initproc) Py_ClassMethod_init,
    .tp_new = Py_ClassMethod_New, //PyType_GenericNew,
};